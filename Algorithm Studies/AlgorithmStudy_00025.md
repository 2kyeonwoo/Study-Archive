# Algorithm Study #24

## RGB 거리

RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.

집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.

* 1번 집의 색은 2번 집의 색과 같지 않아야 한다.
* N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
* i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다

#### 입력

첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.

#### 출력

첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.

### 문제 풀이

```N개의 집을 R/G/B를 이용하여 이웃집과 겹치지 않게 칠하는데 드는 최소 가격```을 구하는 문제입니다. 집의 총 개수는 ```1 <= N <= 1000```이고, N번째 집까지 드는 비용을 각각 구한 다음에 최소 가격을 찾아내야합니다.

``` cpp
#include <iostream>

using namespace std;

int Less(int a, int b) { return (a < b) ? a : b; }

int main() {
    int N;
    int answer = __INT_MAX__;
    int dp[1000][3], temp[1000][3];
    
    cin >> N;

    for (int i = 0; i < N; i++) {
        for (int r = 0; r < 3; r++) {
            cin >> temp[i][r];
        }
    }
    
    dp[0][0] = temp[0][0];
    dp[0][1] = temp[0][1];
    dp[0][2] = temp[0][2];

    for (int i = 1; i < N; i++) {
        dp[i][0] = Less(dp[i - 1][1], dp[i - 1][2]) + temp[i][0];
        dp[i][1] = Less(dp[i - 1][0], dp[i - 1][2]) + temp[i][1];
        dp[i][2] = Less(dp[i - 1][0], dp[i - 1][1]) + temp[i][2];
    }

    for (int i = 0; i < 3; i++) {
        if (dp[N-1][i] < answer)
            answer = dp[N-1][i];
    }

    cout << answer;

    return 0;
}
```